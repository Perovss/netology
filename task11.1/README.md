**Домашнее задание к занятию "11.1 Введение в микросервисы"**

*Плюсы*


1. Высокая отказоустойчивость: при падении одного из сервисов, все остальные остаются в строю. Таким образом, неполадки в отдельных сервисах не помешают всему рабочему процессу.
2. Гибкость: можно попробовать внедрить новую технологию малой кровью. Это будет значительно быстрее и, при неудаче, откатить изменения просто. Меняя локально один из сервисов, мы не рискуем всей системой и время, требующееся для изменений, меньше.
3. Простота: чем меньше кода (а каждый отдельный сервис представляет собой цельную систему, поэтому не нужно разбираться в огромном количестве деталей, не касающихся данной конкретной функции), тем проще программистам разобраться, что и как работает. К тому же, на это уйдет меньше времени.
4. Масштабируемость. Это основной плюс для быстро растушего сервиса. Микросервисная архитектура позволит динамически увеличивать выделяемые ресурсы в зависимости от утилизации и всегда соответствовать нагрузке.
5. Экономия на инфраструктуре.Можно не выделять лишние мощности, если они не используются.
6. Увеличение частоты, скорости и надежности доставки нового функционала. Актуально, если продукт постоянно развивается, а не только наращивает обороты.
7. Надежность. Хотя, конечно, это не следует напрямую из микросервисной архитектуры. Но именно при таком подходе проще реализовать отказоустойчивый продукт.


*Минусы*


1. Сам переход на новую архитектуру будет довольно долгим и дорогостоящим.
2. Нужно больше квалифицированного персонала для осуществления перехода и последующей поддержки.
3. Возможны затраты на дополнительное ПО для автоматизации процессов.

*Проблемы перехода*

**1. Изменение подхода к работе с мастер-данными**

У монолита обычно есть одна или две большие базы данных, содержащие в себе разношерстные мастер-данные. В самом монолите написан код, который управляет этими мастер-данными. Получается в базе данных монолита множество мастер-данных, а в коде монолита много мастер-систем.

В микросервисах управление мастер-данным происходит иначе: баз данных много, перемешивать мастер-данные между микросервисами нельзя, а управлять мастер-данными может только один микросервис.

**2. Невозможность переиспользования исходного кода монолита**

При беглом изучении кода монолита может показаться, что код аккуратно разделен по бизнес-контекстам и в нем не нарушается принцип единственности ответственности. Если это так, значит можно взять код монолита, распределить этот код по микросервисам, соединить микросервисы между собой и получится та же система, но на микросервисной архитектуре.

Практика показывает, что границы ответственности так или иначе растекаются внутри монолита. Из-за этого не получается использовать "копипаст" из монолита для заполнения микросервиса кодом. Весь код и тесты придется написать с нуля для правильного разделения ответственностей по микросервисам.

**3. Проектирование системы заново**

Разработчики так или иначе перепишут код монолита, но нужен кто-то, кто правильно разделит монолит на микросервисы, исходя из бизнес-требований. При проектировании микросервисной архитектуры нужно учесть текущее состояние бизнеса и будущие цели. Придется заново сделать анализ потребностей бизнеса для правильной “нарезки”.

**4. Создание нового подхода к управлению инфраструктурой**

Микросервисы предъявляют новые требования к инфраструктуре. Не получится взять инфраструктуру монолита и на ней развернуть микросервисы. Нужно учесть множество особенностей и применить специальные инструменты, чтобы не попасть в ситуацию, когда вместо монолита вы создали микросервисный монолит:

Создание инфраструктуры для управления API: анализ вызовов, система прав, публикация API и т.д.
Переход DevOps-инженеров на работу только в концепции IaC и контейнеризацию.
Реализовать тотальное логирование и мониторинг микросервисной архитектуры.

**5. Измерение и проверка SLA каждого микросервиса**

Обычно внутри монолита не замеряются SLA вызова функций. Мало кто отслеживает скорость ответа метода в коде или скорость работы хранимки. При разделении монолита на микросервисы, метод, который раньше вызывался из кода, становится вызовом API. Приходится гарантировать другим микросервисам конкретный SLA, чтобы вся конструкция работала предсказуемо.

**6. Микросервисы добавят на порядок больше точек отказа**

Вместе со значительным увеличением числа сервисов по сравнению с монолитом, вы получаете рост точек интеграции, усложнение процесса CI/CD и распределение мастер-данных, что значительно усложнит всю инфраструктуру. Шанс получить проблему на проде будет очень высоким, если целенаправлено не вкладываться в fault tolerance на всех уровнях: проектирование архитектуры, разработка и тестирование.

**7. Реорганизация команд**

Когда монолит распадется на много маленьких независимых микро-систем, то встанет вопрос, как теперь организоваться людей вокруг этого "роя"?

**8. Обратная совместимость с монолитом**

Бизнесу захочется снизить свои риски и не выключать монолит сразу, а переходить на микросервисы постепенно. Функциональность, реализованная в микросервисах, будет работать параллельно с той же функциональностью в монолите. Поэтому придется реализовывать обратную совместимость микросервисов с монолитом. Это первая часть работы, которую нужно закладывать в оценку.

Вторая часть работы связана с тем, что монолит не всегда готов принимать потоки данных в протоколах и форматах удобных для микросервисов. Поэтому часто приходится доделывать функции в монолите, чтобы микросервисы могли отсылать в него данные. Чтобы эти задачи были сделаны, нужно заранее договориться с командой монолита с каким приоритетом и по какому процессу они будут принимать задачи от команды микросервисов.

**9. Интеграция и обучение служб поддержки**

Если система критична для бизнеса, значит у нее уже есть процесс техподдержки. Нужно будет интегрироваться со службой техподдержки и выстроить процесс техподдержки двух систем одновременно.

Это обычные действия при замене старой системы на новую. Но что бывает неожиданно, так это то, что раньше техподдержка иногда залезала в базу данных или правила файлик или "пропихивала" что-то вручную по процессу. А теперь база данных не одна, их много и они разные. Файлики где-то в облаке, а информация летает через очереди.

**10. Догоняющий поток фич от бизнеса**

Пока новая система постепенно заменяет старую, бизнес не стоит на месте. Не получится поставить на паузу поток новых фич. 